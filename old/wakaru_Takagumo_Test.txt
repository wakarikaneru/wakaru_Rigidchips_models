// [RCD] 
Val
{
	AIRBREAK(default=180, min=90, max=180)
	BLADEL(default=0, min=-180, max=180)
	BLADER(default=0, min=-180, max=180)
	BREAK_L(default=0, max=80)
	BREAK_R(default=0, max=80)
	ELEVATOR(default=180, min=150, max=210)
	GEAR_F(default=45, min=45, max=180)
	GEAR_R(default=90, min=90, max=180)
	GEAR_ROT(default=0, min=-30, max=30)
	GUN_1_B(default=0, min=-2147483648, max=2147483647)
	GUN_1_L(default=180, min=90, max=270)
	GUN_1_R(default=180, min=90, max=270)
	GUN_2_B(default=180, min=120, max=180)
	GUN_2_L(default=95, min=95, max=180)
	GUN_2_R(default=95, min=95, max=180)
	GUN_3_B_0(default=90, min=90, max=180)
	GUN_3_B_1(default=90, min=90, max=180)
	GUN_3_B_2(default=90, min=90, max=180)
	GUN_3_B_3(default=90, min=90, max=180)
	GUN_4_B_0(default=180, min=90, max=180)
	GUN_4_B_1(default=180, min=90, max=180)
	GUN_4_B_2(default=180, min=90, max=180)
	GUN_4_B_3(default=180, min=90, max=180)
	GUN_5_B_0(default=-90, min=-90, max=0)
	GUN_5_B_1(default=-90, min=-90, max=0)
	GUN_5_B_2(default=-90, min=-90, max=0)
	GUN_5_B_3(default=-90, min=-90, max=0)
	GUN_TRIG_B_0(default=0, max=50000)
	GUN_TRIG_B_1(default=0, max=50000)
	GUN_TRIG_B_2(default=0, max=50000)
	GUN_TRIG_B_3(default=0, max=50000)
	GUN_TRIG_L(default=0, max=50000)
	GUN_TRIG_R(default=0, max=50000)
	POWER(default=0, max=360000)
	RUDDER(default=180, min=150, max=210)
	TRIM(default=45, min=-2147483648, max=2147483647)
	VIS(default=180, max=360)
}
Key
{
}
Body
{
	Core(name=CORE, user2=811) {
		N:RudderF(angle=VIS, option=1) {
			S:Frame(angle=45, option=1, spring=0.2, damper=0) {
				S:Weight(angle=-45, name=BODY) {
					N:Weight() {
						N:Weight() {
							N:Weight() {
								S:Trim(angle=90) {
									S:RudderF(angle=GEAR_F) {
										S:RLW(angle=GEAR_ROT, option=2, effect=2) { }
									}
								}
								S:Chip(angle=AIRBREAK) { }
								S:Chip(angle=-AIRBREAK) { }
								N:Trim(name=GUN_MOUNT_B, angle=GUN_1_B) {
									N:Rudder(name=GUN_B, angle=GUN_2_B) {
										N:Frame(angle=-GUN_3_B_0, option=1) {
											N:Frame(angle=-GUN_4_B_0, option=1) {
												N:Arm(name=GUN_B_0, angle=-GUN_5_B_0, power=GUN_TRIG_B_0, option=50000) { }
											}
										}
										N:Frame(angle=GUN_3_B_1, option=1) {
											N:Frame(angle=GUN_4_B_1, option=1) {
												N:Arm(name=GUN_B_1, angle=GUN_5_B_1, power=GUN_TRIG_B_1, option=50000) { }
											}
										}
										N:Frame(angle=-GUN_3_B_2, option=1) {
											N:Frame(angle=-GUN_4_B_2, option=1) {
												N:Arm(name=GUN_B_2, angle=-GUN_5_B_2, power=GUN_TRIG_B_2, option=50000) { }
											}
										}
										N:Frame(angle=GUN_3_B_3, option=1) {
											N:Frame(angle=GUN_4_B_3, option=1) {
												N:Arm(name=GUN_B_3, angle=GUN_5_B_3, power=GUN_TRIG_B_3, option=50000) { }
											}
										}
									}
								}
								W:Chip() {
									W:Frame(angle=GEAR_R) {
										S:RudderF(angle=210, option=1) {
											E:RLW(option=2, effect=4, break=BREAK_R) { }
										}
									}
									W:Chip() {
										S:Chip(angle=160) { }
										S:Chip(angle=-160) { }
										N:Jet(angle=30) {
											N:RLW(angle=-120, power=POWER, name=ENGINER) {
												N:Trim(name=PROP_R_0, angle=-BLADER, damper=0.9375, spring=0.9375) { }
												E:Trim(name=PROP_R_1, angle=-BLADER, damper=0.9375, spring=0.9375) { }
												S:Trim(name=PROP_R_2, angle=-BLADER, damper=0.9375, spring=0.9375) { }
												W:Trim(name=PROP_R_3, angle=-BLADER, damper=0.9375, spring=0.9375) { }
											}
										}
										W:Rudder(angle=5) {
											W:Chip() {
												W:Chip() { }
											}
										}
									}
								}
								E:Chip() {
									E:Frame(angle=GEAR_R) {
										S:RudderF(angle=-210, option=1) {
											W:RLW(angle=0, option=2, effect=4, break=BREAK_L) { }
										}
									}
									E:Chip() {
										S:Chip(angle=160) { }
										S:Chip(angle=-160) { }
										N:Jet(angle=30) {
											N:RLW(angle=-120, power=-POWER, name=ENGINEL) {
												N:Trim(name=PROP_L_0, angle=BLADEL, damper=0.9375, spring=0.9375) { }
												E:Trim(name=PROP_L_1, angle=BLADEL, damper=0.9375, spring=0.9375) { }
												S:Trim(name=PROP_L_2, angle=BLADEL, damper=0.9375, spring=0.9375) { }
												W:Trim(name=PROP_L_3, angle=BLADEL, damper=0.9375, spring=0.9375) { }
											}
										}
										E:Rudder(angle=-5) {
											E:Chip() {
												E:Chip() { }
											}
										}
									}
								}
								S:Trim(angle=TRIM) {
									N:Weight(angle=180, option=1) { }
								}
							}
							W:Chip() {
								W:Rudder(angle=15) {
									W:Chip() {
										W:Chip() {
											W:Chip() { }
										}
									}
								}
							}
							E:Chip() {
								E:Rudder(angle=-15) {
									E:Chip() {
										E:Chip() {
											E:Chip() { }
										}
									}
								}
							}
							W:Chip(angle=90) {
								N:Chip() { }
							}
							W:Chip(angle=-90) {
								N:Chip() { }
							}
							E:Chip(angle=90) {
								N:Chip() { }
							}
							E:Chip(angle=-90) {
								N:Chip() { }
							}
						}
						W:Chip(name=GUN_MOUNT_R) {
							W:Jet(angle=GUN_1_R) {
								E:Rudder(angle=-GUN_2_R) {
									W:Arm(power=GUN_TRIG_R, option=50000, name=GUN_R) { }
								}
							}
						}
						E:Chip(name=GUN_MOUNT_L) {
							E:Jet(angle=GUN_1_L) {
								W:Rudder(angle=GUN_2_L) {
									E:Arm(power=GUN_TRIG_L, option=50000, name=GUN_L) { }
								}
							}
						}
						N:Weight(option=5, name=BOMB0, user2=1040) {
							S:TrimF(angle=90, option=1) {
								N:Weight(option=5) { }
							}
						}
						N:Weight(option=5, name=BOMB1, user2=1040) {
							S:TrimF(angle=90, option=1) {
								N:Weight(option=5) { }
							}
						}
						N:Weight(option=5, name=BOMB2, user2=1040) {
							S:TrimF(angle=90, option=1) {
								N:Weight(option=5) { }
							}
						}
					}
					S:Weight(option=1, name=NOSE) {
						S:Jet() {
							S:Jet() {
								S:Jet() {
									S:Weight(option=1) { }
								}
							}
						}
						S:Chip(angle=ELEVATOR) {
							E:Chip() { }
							W:Chip() { }
						}
						S:Chip(angle=ELEVATOR) {
							E:Chip() { }
							W:Chip() { }
						}
					}
					S:TrimF(angle=90, option=1) {
						S:Chip(angle=RUDDER) { }
						S:Chip(angle=RUDDER) { }
					}
				}
			}
		}
	}
}
Lua
{

	KEY_UP=0;
	KEY_DOWN=1;
	KEY_LEFT=2;
	KEY_RIGHT=3;
	KEY_Z=4;
	KEY_X=5;
	KEY_C=6;
	KEY_A=7;
	KEY_S=8;
	KEY_D=9;
	KEY_V=10;
	KEY_B=11;
	KEY_F=12;
	KEY_G=13;
	KEY_Q=14;
	KEY_W=15;
	KEY_E=16;
		
	function analog(i)
		if _ANALOG(i)==0 then
			return 0;
		else
			return (_ANALOG(i)/1000)^2*(_ANALOG(i)/math.abs(_ANALOG(i)));
		end
	end
	
	initflag=false;
	
	require("wakaru/wakaru_eye.lua");
	
function init()
	initflag=true;
	
	eye=Wakaru_Eye.new(CORE, 300);
	BomberCharge=loadlib("BomberDLL.dll", "bomber_Charge");
	
	fire=false;
	fireNum=0;
	
	trimVel=0;
	ldg=true;
	park=false;
	rize=false;
	
	doubleTime=10;
	doubleUp=0;
	
	bombNum=3;
	
	aoa=0;
	pitch=0;
	yaw=0;
	
	visAngle=180;
	visTime=0;
	
	_ZOOM(100);
	
	VECX=Vector.new(1, 0, 0);
	VECY=Vector.new(0, 1, 0);
	VECZ=Vector.new(0, 0, 1);
	
	fbt=0;
end

function main()
	if not initflag then init() end
	
	--処理時間のテスト
	mainStartTime=GetTickCount();
	
	for loop=0, 99 do
		eye:tick();
	end
	
	allTime=GetTickCount()-mainStartTime;
	out(10,allTime);
	
		LimitAmmoRegulation();
		bomberRegulation();
		
		--機体の情報を収集する
		bodySpdW=getSpdVec(BODY);
		bodySpdL=bodySpdW:getLVec(BODY);
		bodyPos=Vector:getPosVec(BODY);
		noseSpdW=getSpdVec(NOSE);
		noseSpdL=bodySpdW:getLVec(NOSE);
		nosePos=Vector:getPosVec(NOSE);
		--
		
		l150=41.67/_BASE();
		
		disp();
		
		s=limit(1/math.abs(bodySpdL.z), 0, 1);
		
		--失速しないように高度を獲得してくれるモード
		if rize then
			pitch=step2(pitch, limit(PID("RIZE", -bodySpdL.z, l150, 1, 0.1, 15, -1, 1, 0.95), -1, 1), 1/20);
		else
			pitch=step2(pitch, _KEY(KEY_UP)-_KEY(KEY_DOWN)+analog(1), 1/20);
		end
		
		yaw=step2(yaw, _KEY(KEY_LEFT)-_KEY(KEY_RIGHT)+analog(0), 1/20);
		
		if _KEYDOWN(KEY_W)==1 then ldg=not ldg; end
		if _KEYDOWN(KEY_E)==1 then park=not park; end
		if _KEYDOWN(KEY_D)==1 then rize=not rize; end
		
		--消火装置
		propR=0;
		propL=0;
		for i=0, 3 do
			if _TOP(_G["PROP_L_"..i])==CORE then
				propL=propL+1;
				if _TOP(_G["PROP_L_"..math.mod(i+2, 4)])~=CORE then
					hoge=_BYE(_G["PROP_L_"..i]);
				end
			end
			if _TOP(_G["PROP_R_"..i])==CORE then
				propR=propR+1;
				if _TOP(_G["PROP_R_"..math.mod(i+2, 4)])~=CORE then
					hoge=_BYE(_G["PROP_R_"..i]);
				end
			end
		end
		
		if not park then
			POWER=limit(POWER+(_KEY(KEY_Q)-_KEY(KEY_A))*6000, 0, 360000);
			if l150<-bodySpdL.z then
				yl=1;
				yr=1;
			else
				yl=1-limit(yaw, 0, 1)*(l150+bodySpdL.z)/l150/2;
				yr=1+limit(yaw, -1, 0)*(l150+bodySpdL.z)/l150/2;
			end
			BLADEL=step2(BLADEL, SAE416((getSpdVec(ENGINEL):getLVec(ENGINEL)*_BASE()).y, _Y(ENGINEL), POWER, -_WY(ENGINEL), propL)*yl, 15);
			BLADER=step2(BLADER, SAE416((getSpdVec(ENGINER):getLVec(ENGINER)*_BASE()).y, _Y(ENGINER), POWER, _WY(ENGINER), propR)*yr, 15);
		else
			POWER=limit(math.floor(math.abs(bodySpdL.z)*60+2)*6000, 0, 360000);
			BLADEL=step2(BLADEL, PID("BLADEL", (getSpdVec(ENGINEL):getLVec(ENGINEL)*_BASE()).y, 0, 1, 0.5, 30, -30, 30, 0.99), 15);
			BLADER=step2(BLADER, PID("BLADER", (getSpdVec(ENGINER):getLVec(ENGINEL)*_BASE()).y, 0, 1, 0.5, 30, -30, 30, 0.99), 15);
		end
		
		hol=math.abs(1-math.abs(VECZ:getWVec(BODY)^VECY));
		
		trimVel=step2(trimVel, -PID("TRIM", math.deg(_AZ(BODY)), limit(bodySpdL.x*2*_BASE(), -30,30), 2, 0.2, 120, -30, 30, 1.00)*hol, 5);
		TRIM=TRIM+trimVel;
		
		aoa=step2(aoa, PID("AOA", -bodySpdW.y, pitch/2, 3, 1, 120, -30, 30, 1.00)*s-5, 5);
		ELEVATOR=step2(ELEVATOR, PID("ELEV", math.deg(_AX(BODY)), aoa, 1, 0.1, 1, -15, 15, 0.9)*s+180, 5);
		RUDDER=step2(RUDDER, PID("RUDD", noseSpdL.x, yaw, 30, 0, 120, -10, 10, 0.9)*s+180, 5);

		if _KEY(KEY_X)==1 then
			AIRBREAK=step2(AIRBREAK, 90, 10);
		else
			AIRBREAK=step2(AIRBREAK, 180, 10);
		end
		
		if _KEY(KEY_Z)==1 or _KEY(KEY_C)==1 then
			visAngle=limit(visAngle+(_KEY(KEY_Z)-_KEY(KEY_C))*5, -0, 360);
			visTime=_BASE();
		end
		
		if visTime<=0 then
			visAngle=step2(visAngle, 180, 5);
			visTime=0;
		else
			visTime=visTime-1;
		end
		
		VIS=step2(VIS, visAngle, 5);
		
		if ldg then
			GEAR_F=step2(GEAR_F, 45, 3);
			GEAR_R=step2(GEAR_R, 90, 3);
			GEAR_ROT=step2(GEAR_ROT, yaw*15*s, 3);
			BREAK_L=step2(BREAK_L, _KEY(KEY_LEFT)*80, 20);
			BREAK_R=step2(BREAK_R, _KEY(KEY_RIGHT)*80, 20);
		else
			GEAR_F=step2(GEAR_F, 180, 3);
			GEAR_R=step2(GEAR_R, 180, 3);
			GEAR_ROT=step2(GEAR_ROT, 0, 5);
		end
		
		--武装に関する処理
		if LimitAmmo<=0 then
			fire=false;
		elseif _KEYDOWN(KEY_F)==1  then
			fire=not fire;
		end
		
		fcs();
		
		--爆装に関する処理
		if _KEYDOWN(KEY_S)==1 and 0<bombNum then
			bombNum=bombNum-1;
			_BYE(_G["BOMB"..bombNum]);
		end
		
		--bomb();
		
		--damageVision();
	
	--
end

function disp()
	--FPSの表示
	out(0, "FPS: ", math.floor(_FPS()+0.5));
	
	--座標の表示
	local pos=Vector:getPosVec(BODY);
	out(1, "POS: [X] ", math.floor(pos.x+0.5), " [Z] ", math.floor(pos.z+0.5));

	--絶対的な速度を視覚的に表示
	drawGround(bodyPos, "000000");
	
	--自機から垂直な線を表示
	drawPin(bodyPos, "00FF00");
	
	--出力の表示
	local i=0;
	local str="["
	while i<math.floor(POWER/12000) do
		i=i+1;
		str=str.."|"
	end
	while i<30 do
		i=i+1;
		str=str.." "
	end
	str=str.."]";
	out(24, str);
	
	--飛行状態の表示
	if rize then
		drawHorizon(BODY, "00FF00");
	else
		drawHorizon(BODY, "008000");
	end
	
	--
	if ldg then
		drawLandingLine(BODY, bodySpdW, "00FF00");
	end
	
	--着陸状態の表示
	if park then
	else
		--進行方向を視覚的に表示
		fbt=math.mod(fbt+1, 30);
		
		drawFBody(BODY, bodyPos+bodySpdW*(30-fbt), "00FF00");
		drawFBody(BODY, bodyPos+bodySpdW*(60-fbt), "00FF00");
		drawFBody(BODY, bodyPos+bodySpdW*(90-fbt), "00FF00");
	end
	
	--爆弾数の表示
	out(21, "BOMB: ", math.floor(bombNum));
	
	--射撃状態の表示
	if fire then
		out(22, "ARM: ON");
	else
		out(22, "ARM: OFF");
	end
	
	--残弾数の表示
	out(23, "AMMO: ", math.floor(LimitAmmo/2));
	
	--EYE操作盤の表示
	eye:dispPlayer(3, KEY_G, KEY_B, KEY_V);
	
	--HOSTILE設定された敵機の一覧を表示
	enemyList="";
	for i=0,_PLAYERS()-1 do
		if eye:getState(_PLAYERID(i))==Player.STATE_HOSTILE then
			enemyList=enemyList.." [ ".._PLAYERNAME(i).." ] ";
		end
	end
	out(4, "ENEMY: "..enemyList);
end

COF=math.cos(math.rad(3));
FIRERATE=2;

THREATLINE=math.cos(math.rad(30));	--これ以下の角度で接近してきた敵機を攻撃対象にする

function fcs()

	targetL=nil;
	targetR=nil;
	targetB=nil;
	
	gunLTrig=false;
	gunRTrig=false;
	gunBTrig=false;
	
	local aimVec=-VECZ;
	local threat=0;
	local threatL=-1;
	local threatR=-1;
	local threatB=THREATLINE;
	
	local rot=0;
	
	--[[
	gunLSpd=getSpdVec(GUN_L);
	gunRSpd=getSpdVec(GUN_R);
	gunBSpd=getSpdVec(GUN_B);
	--]]
	--[[
	gunLSpd=Vector.new(_VX(GUN_L), _VY(GUN_L), _VZ(GUN_L)):getWVec(GUN_L)/_BASE();
	gunRSpd=Vector.new(_VX(GUN_R), _VY(GUN_R), _VZ(GUN_R)):getWVec(GUN_R)/_BASE();
	gunBSpd=Vector.new(_VX(GUN_B), _VY(GUN_B), _VZ(GUN_B)):getWVec(GUN_B)/_BASE();
	--]]
	---[[
	gunLSpd=getSpdVec(GUN_L);
	gunRSpd=getSpdVec(GUN_R);
	gunBSpd=Vector.new(_VX(GUN_B), _VY(GUN_B), _VZ(GUN_B)):getWVec(GUN_B)/_BASE();
	--]]
	
	for i=0,_PLAYERS()-1 do
		id=_PLAYERID(i);
		if eye:getInRange(id) then
			if eye:getState(id)==2 then
				drawTarget(CORE, eye:getNextPos(id), eye:getDis(id), "FF0000");
				
				if fire then
					fp=eye:getFuturePos(_PLAYERMYID(), eye:getReadTime(id));
					aimVec=(fp-eye:getPos(id)):getNormal();
					
					if eye:getVel(id):getLength()<0.05 then
						threat=-1;
					else
						threat=aimVec^eye:getVel(id):getNormal();
					end
					
					aimVec=(eye:getFuturePos(id)-Vector:getPosVec(GUN_MOUNT_L)):getLVec(GUN_MOUNT_L):getNormal();
					if aimVec.x<=0 and aimVec.z<=0 then
						if threatL<=threat then
							threatL=threat;
							targetL=id;
						end
					end
					
					aimVec=(eye:getFuturePos(id)-Vector:getPosVec(GUN_MOUNT_R)):getLVec(GUN_MOUNT_R):getNormal();
					if 0<=aimVec.x and aimVec.z<=0 then
						if threatR<=threat then
							threatR=threat;
							targetR=id;
						end
					end
					
					aimVec=(eye:getFuturePos(id)-Vector:getPosVec(GUN_B)):getLVec(GUN_MOUNT_B):getNormal();
					if math.deg(math.acos(aimVec^(-VECZ)))<=60 then
						if threatB<=threat then
							threatB=threat;
							targetB=id;
						end
					end
				end
				
			else
				if 200<eye:getDis(id) then
					drawTarget(CORE, eye:getNextPos(id), eye:getDis(id), "00AA00");
				elseif 100<eye:getDis(id) then
					drawTarget(CORE, eye:getNextPos(id), eye:getDis(id), "00CC00");
				else
					drawTarget(CORE, eye:getNextPos(id), eye:getDis(id), "00FF00");
				end
			end
		end
	end
	
	if targetL~=nil then
		aimVec=eye:getFuturePos2(targetL, Vector:getPosVec(GUN_L), gunLSpd)-Vector:getPosVec(GUN_L);
		aimVec=aimVec:getLVec(GUN_MOUNT_L):getNormal();
		
		GUN_2_L=step2(GUN_2_L, 90+math.deg(math.acos(aimVec^(-VECX))), 30);
		
		aimVec=aimVec;
		aimVec.x=0;
		aimVec=aimVec:getNormal();
		
		if 0<aimVec.y then
			rot=-math.deg(math.acos(aimVec^(-VECZ)));
		else
			rot=math.deg(math.acos(aimVec^(-VECZ)));
		end
		
		GUN_1_L=step2(GUN_1_L, 180+rot, 30);
		
		aimVec=eye:getFuturePos2(targetL, Vector:getPosVec(GUN_L), gunLSpd)-Vector:getPosVec(GUN_L);
		aimVec=aimVec:getLVec(GUN_L):getNormal();
		if COF<(-VECZ)^aimVec then
			gunLTrig=true;
		end
	else
		GUN_1_L=step2(GUN_1_L, 180, 5);
		GUN_2_L=step2(GUN_2_L, 95, 5);
	end
	
	if targetR~=nil then
		aimVec=eye:getFuturePos2(targetR, Vector:getPosVec(GUN_R), gunLSpd)-Vector:getPosVec(GUN_R);
		aimVec=aimVec:getLVec(GUN_MOUNT_R):getNormal();
		
		GUN_2_R=step2(GUN_2_R, 90+math.deg(math.acos(aimVec^(VECX))), 30);
		
		aimVec=aimVec;
		aimVec.x=0;
		aimVec=aimVec:getNormal();
		
		if 0<aimVec.y then
			rot=-math.deg(math.acos(aimVec^(-VECZ)));
		else
			rot=math.deg(math.acos(aimVec^(-VECZ)));
		end
		
		GUN_1_R=step2(GUN_1_R, 180+rot, 30);
		
		aimVec=eye:getFuturePos2(targetR, Vector:getPosVec(GUN_R), gunRSpd)-Vector:getPosVec(GUN_R);
		aimVec=aimVec:getLVec(GUN_R):getNormal();
		if COF<(-VECZ)^aimVec then
			gunRTrig=true;
		end
	else
		GUN_1_R=step2(GUN_1_R, 180, 5);
		GUN_2_R=step2(GUN_2_R, 95, 5);
	end
	
	if targetB~=nil then
		aimVec=eye:getFuturePos2(targetB, Vector:getPosVec(GUN_B), gunBSpd)-Vector:getPosVec(GUN_B);
		aimVec=aimVec:getLVec(GUN_MOUNT_B):getNormal();
		
		GUN_2_B=step2(GUN_2_B, math.deg(math.acos(aimVec^VECZ)), 10);
		
		aimVec=aimVec;
		aimVec.z=0;
		aimVec=aimVec:getNormal();
		if 0<aimVec.y then
			rot=math.deg(math.acos(aimVec^VECX));
		else
			rot=-math.deg(math.acos(aimVec^VECX));
		end
		
		GUN_1_B=step2(GUN_1_B, GUN_1_B+rot, 10);
		
		aimVec=eye:getFuturePos2(targetB, Vector:getPosVec(GUN_B), gunBSpd)-Vector:getPosVec(GUN_B);
		aimVec=aimVec:getLVec(GUN_B):getNormal();
		if COF<(VECZ)^aimVec then
			gunBTrig=true;
		end
	else
		GUN_1_B=step2(GUN_1_B, 90, 5);
		GUN_2_B=step2(GUN_2_B, 180, 5);
	end
	
	if gunLTrig then
		GUN_TRIG_L=_OPTION(GUN_L);
	else
		GUN_TRIG_L=0;
	end
	
	if gunRTrig then
		GUN_TRIG_R=_OPTION(GUN_R);
	else
		GUN_TRIG_R=0;
	end
	
	if gunBTrig then
		fireFlag=false;
		for i=0, 3 do
			if fireNum==i then
				if _OPTION(_G["GUN_B_"..i])<=_E(_G["GUN_B_"..i]) and _G["GUN_3_B_"..i]==110 then
					_G["GUN_TRIG_B_"..i]=_OPTION(_G["GUN_B_"..i]);
					fireFlag=true;
				else
					_G["GUN_3_B_"..i]=step2(_G["GUN_3_B_"..i], 110, 20/FIRERATE);
					_G["GUN_4_B_"..i]=step2(_G["GUN_4_B_"..i], 140, 40/FIRERATE);
					_G["GUN_5_B_"..i]=step2(_G["GUN_5_B_"..i], -70, 20/FIRERATE);
				end
			else
				_G["GUN_TRIG_B_"..i]=0;
				_G["GUN_3_B_"..i]=step2(_G["GUN_3_B_"..i], 90, 20/FIRERATE);
				_G["GUN_4_B_"..i]=step2(_G["GUN_4_B_"..i], 180, 40/FIRERATE);
				_G["GUN_5_B_"..i]=step2(_G["GUN_5_B_"..i], -90, 20/FIRERATE);
			end
		end
		if fireFlag then
			local n=0;
			local m=0;
			for i=0, 3 do
				if _TOP(_G["GUN_B_"..i])==CORE then
					if m<_E(_G["GUN_B_"..i]) and fireNum~=i then
						n=i;
						m=_E(_G["GUN_B_"..i]);
					end
				end
			end
			fireNum=n;
		end
	else
		for i=0, 3 do
			_G["GUN_TRIG_B_"..i]=0;
		end
	end
	
	----[[
	--]]
end

function bomb()
	_SETCOLOR(tonumber("00FF00", 16));
	local bombPos=Vector:getPosVec(BODY);
	local bombSpd=bodySpdW*_BASE();
	local g=Vector.new(0, -9.8, 0);
	local lim=_BASE();
	
	while _GETY(bombPos.x, bombPos.z)<=bombPos.y and 0<=bombPos.y and 0<=lim do
		bombSpd=bombSpd+g;
		bombPos=bombPos+bombSpd;
		lim=lim-1;
	end
	
	bombPos.y=math.max(_GETY(bombPos.x, bombPos.z), 0);
	
	local p=(Vector:getPosVec(BODY)-bombPos):getLength()/20+5;
	
	_MOVE3D(bombPos.x, bombPos.y, bombPos.z);
	_LINE3D(bombPos.x, bombPos.y+1000, bombPos.z);
	
	_MOVE3D(bombPos.x+p, bombPos.y+4, bombPos.z);
	for i=1, 16 do
		_LINE3D(bombPos.x+math.cos(2*math.pi*i/16)*p, bombPos.y+4, bombPos.z+math.sin(2*math.pi*i/16)*p);
	end
	
	_MOVE3D(bombPos.x+p, bombPos.y+6, bombPos.z);
	for i=1, 16 do
		_LINE3D(bombPos.x+math.cos(2*math.pi*i/16)*p, bombPos.y+6, bombPos.z+math.sin(2*math.pi*i/16)*p);
	end
end

function step2(val, target, step)
	if math.abs(val-target)<=step then
		val=target;
	else
		if target<val then
			val=val-step;
		else
			val=val+step;
		end
	end
	return val;
end

function PID(id, val, target, kp, ki, kd, min, max, damper, debug)
	local p,i,d;
	
	local dis=target-val;
	if _G["PID_I_"..id]==nil then _G["PID_I_"..id]=0 end;
	if _G["PID_D_"..id]==nil then _G["PID_D_"..id]=dis end;

	p=dis*kp;

	_G["PID_I_"..id]=_G["PID_I_"..id]*damper+dis*ki;
	_G["PID_I_"..id]=limit(_G["PID_I_"..id], min, max);
	i=_G["PID_I_"..id];

	d=(dis-_G["PID_D_"..id])*kd;
	_G["PID_D_"..id]=dis;

	if debug~=nil then
		out(debug,id,"  p= ", p, " i= ", i, " d= ", d)
	end

	return p+i+d
end

function limit(val,min,max)
	return math.max(min,math.min(max,val));
end

function getSpdVec(chipName)
	if not _G["getSpdVec_init"..chipName] then
		_G["getSpdVec_prevSpdVec"..chipName]=Vector:getPosVec(chipName);
		_G["getSpdVec_init"..chipName]=true;
	end

	local spdVec=Vector.new(0, 0, 0);
	local posVec=Vector:getPosVec(chipName);
	spdVec=posVec-_G["getSpdVec_prevSpdVec"..chipName];
	
	_G["getSpdVec_prevSpdVec"..chipName]=posVec;

	return spdVec;
end

function drawTarget(chip, pos, dis, col)
	if col==nil then col="00FF00"; end
	_SETCOLOR(tonumber(col, 16));
	
	local p1=(Vector.new(1, 1, 0)*dis/60):getWVec(chip)+pos;
	local p2=(Vector.new(1, -1, 0)*dis/60):getWVec(chip)+pos;
	local p3=(Vector.new(-1, -1, 0)*dis/60):getWVec(chip)+pos;
	local p4=(Vector.new(-1, 1, 0)*dis/60):getWVec(chip)+pos;
	
	_MOVE3D(p1.x,p1.y,p1.z);
	_LINE3D(p2.x,p2.y,p2.z);
	_LINE3D(p3.x,p3.y,p3.z);
	_LINE3D(p4.x,p4.y,p4.z);
	_LINE3D(p1.x,p1.y,p1.z);
end

function drawFBody(chip, pos, col)
	if col==nil then col="00FF00"; end
	_SETCOLOR(tonumber(col, 16));
	
	local p=pos;
	local p1=Vector.new(-3.3, -1.2, 0):getWVec(chip)+p;
	local p2=Vector.new(-3.3, 1.2, 0):getWVec(chip)+p;
	local p3=Vector.new(3.3, 1.2, 0):getWVec(chip)+p;
	local p4=Vector.new(3.3, -1.2, 0):getWVec(chip)+p;
	
	_MOVE3D(p1.x,p1.y,p1.z);
	_LINE3D(p2.x,p2.y,p2.z);
	_LINE3D(p3.x,p3.y,p3.z);
	_LINE3D(p4.x,p4.y,p4.z);
	_LINE3D(p1.x,p1.y,p1.z);
	
	if ldg then
		local p5=Vector.new(-0.9, -1.2-0.6, 0):getWVec(chip)+p;
		local p6=Vector.new(-0.9, -1.2+0.6, 0):getWVec(chip)+p;
		local p7=Vector.new(0.9, -1.2-0.6, 0):getWVec(chip)+p;
		local p8=Vector.new(0.9, -1.2+0.6, 0):getWVec(chip)+p;
		_MOVE3D(p5.x,p5.y,p5.z);
		_LINE3D(p6.x,p6.y,p6.z);
		_MOVE3D(p7.x,p7.y,p7.z);
		_LINE3D(p8.x,p8.y,p8.z);
	end
end

function drawGround(pos, col)
	if col==nil then col="00FF00"; end
	_SETCOLOR(tonumber(col, 16));
	
	local p=Vector.new(math.floor(pos.x/100)*100+50, pos.y-10, math.floor(pos.z/100)*100+50);

	local p1=Vector.new(350, 0, 50)+p;
	local p2=Vector.new(-350, 0, 50)+p;
	local p3=Vector.new(-350, 0, -50)+p;
	local p4=Vector.new(350, 0, -50)+p;
	
	_MOVE3D(p1.x,p1.y,p1.z);
	_LINE3D(p2.x,p2.y,p2.z);
	_LINE3D(p3.x,p3.y,p3.z);
	_LINE3D(p4.x,p4.y,p4.z);
	_LINE3D(p1.x,p1.y,p1.z);
	
	p1=Vector.new(250, 0, 150)+p;
	p2=Vector.new(-250, 0, 150)+p;
	p3=Vector.new(-250, 0, -150)+p;
	p4=Vector.new(250, 0, -150)+p;
	
	_MOVE3D(p1.x,p1.y,p1.z);
	_LINE3D(p2.x,p2.y,p2.z);
	_LINE3D(p3.x,p3.y,p3.z);
	_LINE3D(p4.x,p4.y,p4.z);
	_LINE3D(p1.x,p1.y,p1.z);	
	
	p1=Vector.new(150, 0, 250)+p;
	p2=Vector.new(-150, 0, 250)+p;
	p3=Vector.new(-150, 0, -250)+p;
	p4=Vector.new(150, 0, -250)+p;
	
	_MOVE3D(p1.x,p1.y,p1.z);
	_LINE3D(p2.x,p2.y,p2.z);
	_LINE3D(p3.x,p3.y,p3.z);
	_LINE3D(p4.x,p4.y,p4.z);
	_LINE3D(p1.x,p1.y,p1.z);
	
	p1=Vector.new(50, 0, 350)+p;
	p2=Vector.new(-50, 0, 350)+p;
	p3=Vector.new(-50, 0, -350)+p;
	p4=Vector.new(50, 0, -350)+p;
	
	_MOVE3D(p1.x,p1.y,p1.z);
	_LINE3D(p2.x,p2.y,p2.z);
	_LINE3D(p3.x,p3.y,p3.z);
	_LINE3D(p4.x,p4.y,p4.z);
	_LINE3D(p1.x,p1.y,p1.z);
end

function drawPin(pos, col)
	if col==nil then col="00FF00"; end
	_SETCOLOR(tonumber(col, 16));
	
	--[[
	_MOVE3D(pos.x,pos.y-5,pos.z);
	_LINE3D(pos.x,0,pos.z);
	--]]
	_MOVE3D(pos.x-1,pos.y-10,pos.z);
	_LINE3D(pos.x+1,pos.y-10,pos.z);
	_MOVE3D(pos.x,pos.y-10,pos.z-1);
	_LINE3D(pos.x,pos.y-10,pos.z+1);
end

function drawHorizon(chip, col)
	if col==nil then col="00FF00"; end
	_SETCOLOR(tonumber(col, 16));
	local vec=Vector.new(0, 0, 1);
	
	vec=Vector.new(0, 0, 1):getWVec(chip);
	local vecH=Vector.new(vec.x, 0, vec.z):getNormal();
	vec=Vector.new(1, 0, 0):getWVec(chip);
	local vecS=Vector.new(vec.x, 0, vec.z):getNormal();
	
	local p=Vector:getPosVec(chip);
	local l0=p+vecS*10+vecH*1000;
	local l1=p+vecS*10-vecH*1000;
	local r0=p-vecS*10+vecH*1000;
	local r1=p-vecS*10-vecH*1000;
	_MOVE3D(l0.x, l0.y, l0.z);
	_LINE3D(l1.x,l1.y,l1.z);
	_MOVE3D(r0.x, r0.y, r0.z);
	_LINE3D(r1.x,r1.y,r1.z);
end

function drawLandingLine(chip, spd, col)
	if col==nil then col="00FF00"; end
	_SETCOLOR(tonumber(col, 16));
	
	local vec=Vector.new(spd.x, 0, spd.z);
	if vec:getLength()<0.1 then
		vec=VECZ:getWVec(chip);
	end
	local vecH=Vector.new(vec.x, 0, vec.z):getNormal();
	
	local p=Vector:getPosVec(chip);
	local l0=p+vecH*100000;
	local l1=p-vecH*100000;
	local y=math.max(_GETY(p.x, p.z), 0);
	
	_MOVE3D(l0.x, y+1, l0.z);
	_LINE3D(l1.x, y+1, l1.z);
end

function radar(chip)
end

function bomberRegulation()
	BomberCharge(GUN_L);
	BomberCharge(GUN_R);
	for i=0, 3 do
		BomberCharge(_G["GUN_B_"..i]);
	end
end

function damageVision()
	drawChip=function(chip)
		local cp=Vector:getPosVec(chip);
		local p0=Vector.new(0.3, 0.03, 0.3):getWVec(chip)+cp;
		local p1=Vector.new(0.3, 0.03, -0.3):getWVec(chip)+cp;
		local p2=Vector.new(-0.3, 0.03, -0.3):getWVec(chip)+cp;
		local p3=Vector.new(-0.3, 0.03, 0.3):getWVec(chip)+cp;
		
		local p4=Vector.new(0.3, -0.03, 0.3):getWVec(chip)+cp;
		local p5=Vector.new(0.3, -0.03, -0.3):getWVec(chip)+cp;
		local p6=Vector.new(-0.3, -0.03, -0.3):getWVec(chip)+cp;
		local p7=Vector.new(-0.3, -0.03, 0.3):getWVec(chip)+cp;
		
		_MOVE3D(p3.x, p3.y, p3.z);
		_LINE3D(p0.x, p0.y, p0.z);
		_LINE3D(p1.x, p1.y, p1.z);
		_LINE3D(p2.x, p2.y, p2.z);
		_LINE3D(p3.x, p3.y, p3.z);
		
		_MOVE3D(p7.x, p7.y, p7.z);
		_LINE3D(p4.x, p4.y, p4.z);
		_LINE3D(p5.x, p5.y, p5.z);
		_LINE3D(p6.x, p6.y, p6.z);
		_LINE3D(p7.x, p7.y, p7.z);
	end
	
	for i=0, _CHIPS()-1 do
		if _T(i)<=0 then
			_SETCOLOR(tonumber("000000", 16));
		elseif _T(i)<=5000 then
			_SETCOLOR(tonumber("FF0000", 16));
		elseif _T(i)<10000 then
			_SETCOLOR(tonumber("FFFF00", 16));
		else
			_SETCOLOR(tonumber("FFFFFF", 16));
		end
		
		drawChip(i);
	end
end

---------------------------------------------------------------- ;
--[[
  Seydlitz Aero Engines AG.
  ㈱ザイドリッツ航空発動機製造

  SAE416 "Nieselregen II" - Operating manual
  霧雨二型 - 運用マニュアル

  ①
  このエンジンは次のような設計を対象にしています。
  異なる場合は、最大の性能を保障するためにも
  SAE製の他のエンジンをお求めください。
    プロペラ枚数 : 2 - 4
    エンジン出力 : 180,000 - 360,000
    実用上昇限度 : 6000m

  構造例 1:
	N:Frame(Angle=-30,Damper=0.9375,Spring=0.9375){
		N:RLW(Name=ENGINE,Angle=120,Damper=0.9375,Spring=0.9375,Power=THRUST){
			N:Trim(Angle=-BLADE,Damper=0.9375,Spring=0.9375){}
			S:Trim(Angle=-BLADE,Damper=0.9375,Spring=0.9375){}
			E:Trim(Angle=-BLADE,Damper=0.9375,Spring=0.9375){}
			W:Trim(Angle=-BLADE,Damper=0.9375,Spring=0.9375){}
		}
	}

  構造例 2:
	N:Frame(Angle=-30,Damper=0.9375,Spring=0.9375){
		N:RLW(Name=ENGINE,Angle=120,Damper=0.9375,Spring=0.9375,Power=THRUST){
			N:Trim(Angle=-BLADE,Damper=0.9375,Spring=0.9375){}
			S:Trim(Angle=-BLADE,Damper=0.9375,Spring=0.9375){}
		}
	}

  ②
  次に示すライン
    ---------------------------------------------------------------- ;
  で囲まれる範囲を機体のLuaにコピーしてください。
  ただし main() 等の関数の中は避けてください。

  ③
  main() 関数ないしは処理のどこかで次に示す関数
    [プロペラピッチを示すVAL変数名] = SAE416( [前進速度] , [高度] , [出力] , [エンジン回転数] , [ブレード枚数] )
  を呼び出してください。
  エンジンに使われているホイール付近の速度が
  もっとも適切と思われるので、たとえば次のような場合
    エンジンのホイール名 : name = ENGINE
    プロペラピッチの変数 : angle = ±BLADE
    エンジン出力         : power = THRUST
    ブレード枚数         : 4
  ならば、次のような例になります。
    BLADE = ±SAE416( ±_VY(ENGINE), _Y(ENGINE), ±THRUST, ±_WY(ENGINE), 4 );
  ただし、±は前進時に値が正になるように適宜調整してください。

  ④機能紹介
    1. エンジン出力をゼロにすると惰性飛行モードに入ります。
    2. 対応出力における最高効率を提供します。
    3. 対応高度における最高効率を提供します。
    4. 対応ブレード枚数における最高効率を提供します。
  
]]
SAE416DatAlt = {300, 1000, 2000, 3000, 4000, 5000, 6000};
SAE416DatPwr = {180000, 360000};
SAE416Dat = {
	[2] = {
		[180000] = {};
		[360000] = {};
	};
	[4] = {
		[180000] = {};
		[360000] = {};
	};
};
SAE416Dat[2][180000][0] = {
	MinVel =  -2.677664	;
	MinAng =   0.86466496110832802	;
	[0] =  4.2446139492086559	;
	[1] =  1.9014540791614643	;
	[2] =  0.12539276732577509	;
	[3] = -0.030388096517108498	;
	[4] =  0.0035994156411873479	;
	[5] = -0.00027630560828737199	;
	[6] =  0.000014633450029450371	;
	[7] = -0.00000055000377836943402	;
	[8] =  0.000000014744199958217255	;
	[9] = -0.0000000002784625973407689	;
	[10] =  0.0000000000035998178532640037	;
	[11] = -0.00000000000003018775530705908	;
	[12] =  0.00000000000000014749488383067818	;
	[13] = -0.00000000000000000031805209920818614	;
	MaxVel =  74.995345999999998	;
	MaxAng =  76.072678407537751	;
};
SAE416Dat[2][360000][0] = {
	MinVel =   0.182781	;
	MinAng =   4.2274433621594047	;

	[0] =  4.0351822893331359	;
	[1] =  1.0271653769832589	;
	[2] =  0.13730726956266537	;
	[3] = -0.011967561024727638	;
	[4] =  0.00049858964908116839	;
	[5] = -0.000011852749475333399	;
	[6] =  0.00000015501234682449067	;
	[7] = -0.00000000086354702837868556	;
	[8] = -0.0000000000013040966533385843	;
	[9] =  0.000000000000024803586054022669	;
	[10] = 0.	;
	[11] = 0.	;
	[12] = 0.	;
	[13] = 0.	;
	MaxVel =  70.345695000000006	;
	MaxAng =  68.675221828615008	;
};
SAE416Dat[4][180000][0] = {
	MinVel =  -1.9992350000000001	;
	MinAng =   1.1989944238255885	;
	[0] =  4.8580904143774717	;
	[1] =  2.2698946082472258	;
	[2] =  0.12009229803800636	;
	[3] = -0.037506250990974932	;
	[4] =  0.0052887030251932005	;
	[5] = -0.0004206726774262223	;
	[6] =  0.000019622651632267496	;
	[7] = -0.00000053703606899947355	;
	[8] =  0.000000007665977928830052	;
	[9] = -0.000000000013472187165227526	;
	[10] = -0.0000000000014198101299231878	;
	[11] =  0.000000000000023912599526258464	;
	[12] = -0.0000000000000001687540555720393	;
	[13] =  0.00000000000000000046323345531409463	;
	MaxVel =  73.064423000000005	;
	MaxAng =  79.918634680099785	;
};
SAE416Dat[4][360000][0] = {
	MinVel =   0.65013900000000002	;
	MinAng =   4.4868074665630386	;
	[0] =  3.0905116220261277	;
	[1] =  2.2057693908650933	;
	[2] = -0.10748291070122207	;
	[3] =  0.030416755729962053	;
	[4] = -0.0040337916708709093	;
	[5] =  0.00028487505488285127	;
	[6] = -0.000011914744121254721	;
	[7] =  0.00000030239558290790933	;
	[8] = -0.0000000044125752390040158	;
	[9] =  0.000000000026574850566707629	;
	[10] =  0.00000000000019242859529531194	;
	[11] = -0.0000000000000046059208431298036	;
	[12] =  0.000000000000000031214328386143728	;
	[13] = -0.000000000000000000076403518040850942	;
	MaxVel =  73.885666000000001	;
	MaxAng =  74.883033075981075	;
};
SAE416Dat[2][180000][300] = {
	MinVel = -30.008841	;
	MinAng =  24.106831068032822	;
	[0] = 42.744659969751638	;
	[1] =  0.66695428486790898	;
	[2] = -0.00033395057100727571	;
	[3] = -0.000049526922873892798	;
	[4] = -0.000003491164434496419	;
	[5] =  0.000000022364349217199732	;
	[6] =  0.0000000046210875605246452	;
	[7] = -0.00000000010594027429655587	;
	[8] = -0.0000000000005210974367489709	;
	[9] =  0.000000000000050964571373007826	;
	[10] = -0.00000000000000084134225277694024	;
	[11] =  0.0000000000000000067414894675139611	;
	[12] = -0.000000000000000000027498926978955131	;
	[13] =  0.000000000000000000000045832435540765351	;
	MaxVel = 129.473434	;
	MaxAng =  86.300471084192395	;
};
SAE416Dat[2][180000][1000] = {
	MinVel = -30.012796000000002	;
	MinAng =  24.941484320809739	;
	[0] = 43.613718070524399	;
	[1] =  0.67809795977465337	;
	[2] = -0.0012266764769531466	;
	[3] = -0.00009942659770941875	;
	[4] = -0.0000004545452628443933	;
	[5] = -0.000000017922965621633721	;
	[6] =  0.0000000036670925513704311	;
	[7] = -0.000000000047965799152795926	;
	[8] = -0.0000000000020649189142378752	;
	[9] =  0.000000000000076691811565068799	;
	[10] = -0.0000000000000011119286567314938	;
	[11] =  0.0000000000000000084641147196019349	;
	[12] = -0.000000000000000000033535036853465628	;
	[13] =  0.000000000000000000000054754310244616454	;
	MaxVel = 129.309967	;
	MaxAng =  86.619834719313076	;
};
SAE416Dat[2][180000][2000] = {
	MinVel = -29.992477000000001	;
	MinAng =  26.599392995166898	;
	[0] = 44.749059277446591	;
	[1] =  0.62942538366936307	;
	[2] = -0.00061165773927492062	;
	[3] = -0.000055177885668866483	;
	[4] = -0.0000016589936362998631	;
	[5] =  0.00000001914104403965668	;
	[6] =  0.0000000017735649053582892	;
	[7] = -0.000000000041549740109848739	;
	[8] = -0.00000000000011691765921932347	;
	[9] =  0.000000000000016331154895744766	;
	[10] = -0.00000000000000027173591539255839	;
	[11] =  0.0000000000000000021958330797274526	;
	[12] = -0.0000000000000000000091258342161249966	;
	[13] =  0.000000000000000000000015656409197496827	;
	MaxVel = 129.519577	;
	MaxAng =  88.222054971774924	;
};
SAE416Dat[2][180000][3000] = {
	MinVel = -30.023264000000001	;
	MinAng =  28.963583825733259	;
	[0] = 46.09724186895717	;
	[1] =  0.63231449192310207	;
	[2] = -0.0024584263188283939	;
	[3] = -0.00016701633585433444	;
	[4] =  0.0000045721327382635397	;
	[5] =  0.00000013026907208890276	;
	[6] = -0.0000000076383836462284131	;
	[7] =  0.000000000046660472344790423	;
	[8] =  0.0000000000037693077472438662	;
	[9] = -0.00000000000010812935199830225	;
	[10] =  0.0000000000000013654697991186165	;
	[11] = -0.0000000000000000093347021175463661	;
	[12] =  0.000000000000000000033616737748205492	;
	[13] = -0.000000000000000000000050083597554308655	;
	MaxVel = 129.42569	;
	MaxAng =  89.676904572785133	;
};
SAE416Dat[2][180000][4000] = {
	MinVel = -30.007019	;
	MinAng =  30.161074314922647	;
	[0] = 46.930603621981206	;
	[1] =  0.5919299547367034	;
	[2] = -0.0013589379858725201	;
	[3] = -0.00012345698495551806	;
	[4] =  0.0000040649474961474254	;
	[5] =  0.000000069134951240250888	;
	[6] = -0.0000000075729884297424509	;
	[7] =  0.00000000010917213495953644	;
	[8] =  0.000000000002694184848180225	;
	[9] = -0.00000000000011172952390890586	;
	[10] =  0.0000000000000016330965498320975	;
	[11] = -0.000000000000000012309287717087889	;
	[12] =  0.000000000000000000047840576540694869	;
	[13] = -0.000000000000000000000076033560792844321	;
	MaxVel = 129.02932699999999	;
	MaxAng =  90.52972633522586	;
};
SAE416Dat[2][180000][5000] = {
	MinVel = -30.497858000000001	;
	MinAng =  31.043249490682072	;
	[0] = 48.052719808991185	;
	[1] =  0.58326267597092762	;
	[2] = -0.00068399476961557293	;
	[3] = -0.00009495801675188774	;
	[4] = -0.0000005206944870550715	;
	[5] =  0.000000059039160348785908	;
	[6] =  0.00000000013741429008042814	;
	[7] = -0.000000000036080253107609015	;
	[8] =  0.00000000000031958076575585173	;
	[9] =  0.000000000000010541277600914292	;
	[10] = -0.00000000000000028039188169868285	;
	[11] =  0.0000000000000000028451487554809078	;
	[12] = -0.000000000000000000013799974059619316	;
	[13] =  0.000000000000000000000026559437254803491	;
	MaxVel = 126.87370300000001	;
	MaxAng =  90.208488922464312	;
};
SAE416Dat[2][180000][6000] = {
	MinVel = -30.651373	;
	MinAng =  32.997846567819721	;
	[0] = 49.020683818608084	;
	[1] =  0.54213949015565321	;
	[2] = -0.00092493977298408608	;
	[3] = -0.000075539908916230836	;
	[4] = -0.00000001280452407565445	;
	[5] =  0.00000010287140294531939	;
	[6] = -0.000000002419442733438575	;
	[7] = -0.000000000037533312282352646	;
	[8] =  0.0000000000024229762555743286	;
	[9] = -0.000000000000041514539324141975	;
	[10] =  0.0000000000000003228299503405953	;
	[11] = -0.00000000000000000092783227709653916	;
	[12] = -0.0000000000000000000015762452832708072	;
	[13] =  0.000000000000000000000010611325231098744	;
	MaxVel = 125.957176	;
	MaxAng =  89.903543254833494	;
};
SAE416Dat[2][360000][300] = {
	MinVel = -30.032883000000002	;
	MinAng =  28.399731406773562	;
	[0] = 44.391932967233195	;
	[1] =  0.50512010267281404	;
	[2] = -0.0011961569830905641	;
	[3] =  0.000082198847174811763	;
	[4] = -0.0000015103125114142795	;
	[5] = -0.0000002010520842821669	;
	[6] =  0.000000005225013596004777	;
	[7] =  0.000000000079888356854579499	;
	[8] = -0.0000000000041464907295749446	;
	[9] =  0.000000000000040856922056560772	;
	[10] =  0.00000000000000022149203110815946	;
	[11] = -0.0000000000000000068894922441284402	;
	[12] =  0.000000000000000000047251005926129914	;
	[13] = -0.00000000000000000000011040497996781019	;
	MaxVel = 116.96867399999999	;
	MaxAng =  82.423480832119822	;
};
SAE416Dat[2][360000][1000] = {
	MinVel = -31.017944	;
	MinAng =  28.750611941820512	;
	[0] = 45.119566245236996	;
	[1] =  0.50743996464972763	;
	[2] = -0.0014958686497740237	;
	[3] = -0.000029105732190357688	;
	[4] =  0.0000011446718406765275	;
	[5] = -0.000000059234884291221591	;
	[6] =  0.0000000013088214526051579	;
	[7] =  0.000000000022576171476890905	;
	[8] = -0.0000000000018830876070443796	;
	[9] =  0.00000000000004457530088511573	;
	[10] = -0.0000000000000005505881413221349	;
	[11] =  0.0000000000000000038048633213376341	;
	[12] = -0.000000000000000000013862062212404191	;
	[13] =  0.000000000000000000000020620320145808966	;
	MaxVel = 116.992615	;
	MaxAng =  84.083578067848066	;
};
SAE416Dat[2][360000][2000] = {
	MinVel = -30.018360000000001	;
	MinAng =  31.701825454278531	;
	[0] = 46.022406415839939	;
	[1] =  0.48776691621060375	;
	[2] =  0.00068770159601682377	;
	[3] =  0.000010649340857321263	;
	[4] = -0.0000067892975600667267	;
	[5] =  0.000000018084759598958774	;
	[6] =  0.0000000092573707807705461	;
	[7] = -0.00000000019617275757612314	;
	[8] = -0.0000000000018447588605619357	;
	[9] =  0.00000000000012288966194365167	;
	[10] = -0.0000000000000019761420391478616	;
	[11] =  0.000000000000000015723111544675543	;
	[12] = -0.000000000000000000063791284607218818	;
	[13] =  0.00000000000000000000010552745963433829	;
	MaxVel = 114.97283899999999	;
	MaxAng =  83.71859634116845	;
};
SAE416Dat[2][360000][3000] = {
	MinVel = -29.970103999999999	;
	MinAng =  32.952581950526984	;
	[0] = 47.275412017875006	;
	[1] =  0.46516962782175392	;
	[2] = -0.0012786597755491012	;
	[3] = -0.000026214132254927675	;
	[4] =  0.0000005639136917374917	;
	[5] =  0.000000018819225096263389	;
	[6] = -0.0000000011523372451219337	;
	[7] =  0.0000000000027723120540988761	;
	[8] =  0.00000000000073950257772926638	;
	[9] = -0.000000000000017765218594392492	;
	[10] =  0.00000000000000018750250777327737	;
	[11] = -0.0000000000000000010072087838687637	;
	[12] =  0.0000000000000000000025462171761579335	;
	[13] = -0.0000000000000000000000020347592061032513	;
	MaxVel = 115.803223	;
	MaxAng =  86.958868848010752	;
};
SAE416Dat[2][360000][4000] = {
	MinVel = -30.057562000000001	;
	MinAng =  34.44341717265543	;
	[0] = 48.211302971977048	;
	[1] =  0.44267366997313595	;
	[2] =  0.00047681368271619562	;
	[3] = -0.000031453233794318837	;
	[4] = -0.0000064178361326877484	;
	[5] =  0.00000015505633064685427	;
	[6] =  0.0000000066865071552207436	;
	[7] = -0.00000000027575368790170697	;
	[8] =  0.00000000000074126085232743876	;
	[9] =  0.00000000000011419041111771615	;
	[10] = -0.0000000000000024547284445906268	;
	[11] =  0.000000000000000023019299050292962	;
	[12] = -0.00000000000000000010572660276775776	;
	[13] =  0.00000000000000000000019393113542745833	;
	MaxVel = 115.827316	;
	MaxAng =  83.672406955287443	;
};
SAE416Dat[2][360000][5000] = {
	MinVel = -29.974862999999999	;
	MinAng =  36.166330535766598	;
	[0] = 49.056550866599615	;
	[1] =  0.44879598441401675	;
	[2] = -0.0019300393766869461	;
	[3] = -0.000019131419206691092	;
	[4] =  0.0000013871412518811506	;
	[5] = -0.0000000070538651677189208	;
	[6] = -0.000000001443021216405465	;
	[7] =  0.000000000020994210529035908	;
	[8] =  0.0000000000010211101902802736	;
	[9] = -0.000000000000041616360124139572	;
	[10] =  0.00000000000000067744079509877059	;
	[11] = -0.0000000000000000059023819622833443	;
	[12] =  0.000000000000000000027218284144102343	;
	[13] = -0.000000000000000000000052377472301924852	;
	MaxVel = 115.97473100000001	;
	MaxAng =  87.294480406373623	;
};
SAE416Dat[2][360000][6000] = {
	MinVel = -30.001324	;
	MinAng =  36.993876463845936	;
	[0] = 49.678001859269756	;
	[1] =  0.44718652722935059	;
	[2] =  0.00017984318765240301	;
	[3] = -0.00010557575801792101	;
	[4] = -0.0000018694079673017445	;
	[5] =  0.00000017559570458899542	;
	[6] = -0.0000000011869179548270874	;
	[7] = -0.00000000010343900228207188	;
	[8] =  0.000000000002642224381518061	;
	[9] = -0.0000000000000213510781864573	;
	[10] = -0.000000000000000032839283391645131	;
	[11] =  0.0000000000000000014955940188722713	;
	[12] = -0.0000000000000000000079615432768323212	;
	[13] =  0.000000000000000000000012654834706771564	;
	MaxVel = 117.049561	;
	MaxAng =  89.232384880482641	;
};
SAE416Dat[4][180000][300] = {
	MinVel = -30.360050000000001	;
	MinAng =  18.313963246023867	;
	[0] = 41.463261817398845	;
	[1] =  0.87667576726941698	;
	[2] = -0.0015253582775190955	;
	[3] = -0.00019629584498416497	;
	[4] = -0.000000081992036307083042	;
	[5] =  0.000000056620646652687115	;
	[6] =  0.0000000018969887578633833	;
	[7] = -0.000000000060170664547742438	;
	[8] = -0.00000000000063656673160219872	;
	[9] =  0.000000000000043418786181780144	;
	[10] = -0.0000000000000007038264292258755	;
	[11] =  0.0000000000000000055843878446439957	;
	[12] = -0.000000000000000000022463224943893092	;
	[13] =  0.000000000000000000000036721213545771085	;
	MaxVel = 134.27024800000001	;
	MaxAng =  86.768938738241559	;
};
SAE416Dat[4][180000][1000] = {
	MinVel = -30.458548	;
	MinAng =  19.18079092699757	;
	[0] = 42.762485880477527	;
	[1] =  0.82588759527808153	;
	[2] = -0.0043309661651522516	;
	[3] = -0.00003859712156854757	;
	[4] =  0.0000030136801203500189	;
	[5] = -0.00000019283700940439235	;
	[6] =  0.0000000038887529175257916	;
	[7] =  0.000000000047366558542082995	;
	[8] = -0.0000000000036262867701625291	;
	[9] =  0.000000000000075579208326347448	;
	[10] = -0.00000000000000084653153247137982	;
	[11] =  0.0000000000000000054915259644109979	;
	[12] = -0.000000000000000000019467579217045918	;
	[13] =  0.000000000000000000000029262325508102447	;
	MaxVel = 134.25058000000001	;
	MaxAng =  86.962075445771916	;
};
SAE416Dat[4][180000][2000] = {
	MinVel = -29.994049	;
	MinAng =  21.503611750446314	;
	[0] = 43.785080991203898	;
	[1] =  0.79086061938771979	;
	[2] = -0.0026840126508850259	;
	[3] = -0.00009072579129105389	;
	[4] =  0.0000012788999923581727	;
	[5] = -0.000000013926095352756402	;
	[6] =  0.00000000016489309611151947	;
	[7] = -0.00000000000094366203391433684	;
	[8] = -0.000000000000032800235641655508	;
	[9] =  0.0000000000000022471124370081274	;
	[10] = -0.000000000000000051848007836111453	;
	[11] =  0.00000000000000000055801010255714366	;
	[12] = -0.0000000000000000000028760258762361581	;
	[13] =  0.0000000000000000000000057625589328665406	;
	MaxVel = 134.14544699999999	;
	MaxAng =  87.641369971461245	;
};
SAE416Dat[4][180000][3000] = {
	MinVel = -30.53219	;
	MinAng =  23.163687168665625	;
	[0] = 44.941927891383727	;
	[1] =  0.80781924355622747	;
	[2] = -0.0010884231773236885	;
	[3] = -0.00023712190424612394	;
	[4] =  0.00000011540904441605663	;
	[5] =  0.00000015159997014338082	;
	[6] = -0.00000000095682549959309549	;
	[7] = -0.00000000006237400129017986	;
	[8] =  0.00000000000096124821717090832	;
	[9] =  0.0000000000000065140024616242245	;
	[10] = -0.00000000000000028214743201750203	;
	[11] =  0.0000000000000000028734602368547746	;
	[12] = -0.000000000000000000013092745704259489	;
	[13] =  0.000000000000000000000023147506643556504	;
	MaxVel = 134.377228	;
	MaxAng =  89.863138180327951	;
};
SAE416Dat[4][180000][4000] = {
	MinVel = -30.405688999999999	;
	MinAng =  25.319830328817403	;
	[0] = 46.355627056281307	;
	[1] =  0.75436465190032842	;
	[2] = -0.0021337136572610327	;
	[3] = -0.00014384593997679896	;
	[4] =  0.0000014594652237168405	;
	[5] =  0.000000044200336360240346	;
	[6] = -0.0000000012177759190356395	;
	[7] = -0.0000000000018788164956019932	;
	[8] =  0.00000000000053342642138902224	;
	[9] = -0.0000000000000094540353152908658	;
	[10] =  0.000000000000000068991470676268237	;
	[11] = -0.00000000000000000014119862577643602	;
	[12] = -0.00000000000000000000073729446400843794	;
	[13] =  0.0000000000000000000000031049915388645065	;
	MaxVel = 134.12402299999999	;
	MaxAng =  90.24818745326229	;
};
SAE416Dat[4][180000][5000] = {
	MinVel = -30.454687	;
	MinAng =  26.907469691030592	;
	[0] = 47.587477409213733	;
	[1] =  0.73428054369339979	;
	[2] = -0.0032162573594762961	;
	[3] = -0.00020284367495921685	;
	[4] =  0.0000068737549374200594	;
	[5] =  0.000000075648537501528161	;
	[6] = -0.0000000084581040384767119	;
	[7] =  0.00000000011394756166942138	;
	[8] =  0.0000000000021818106397995471	;
	[9] = -0.000000000000085756078525122255	;
	[10] =  0.0000000000000011501861233329426	;
	[11] = -0.0000000000000000079494895266419271	;
	[12] =  0.000000000000000000028374456596726835	;
	[13] = -0.000000000000000000000041471153229520115	;
	MaxVel = 134.06021100000001	;
	MaxAng =  91.175081597844837	;
};
SAE416Dat[4][180000][6000] = {
	MinVel = -30.007757000000002	;
	MinAng =  29.089217498360259	;
	[0] = 48.656172665135784	;
	[1] =  0.70720834725802861	;
	[2] = -0.0015038647790237905	;
	[3] = -0.00015732911473154956	;
	[4] = -0.0000014747538295325821	;
	[5] =  0.00000012655096340857627	;
	[6] =  0.0000000016000236173813431	;
	[7] = -0.00000000011701030054816601	;
	[8] =  0.00000000000078821665481610496	;
	[9] =  0.000000000000032350627747499959	;
	[10] = -0.00000000000000074552035469811621	;
	[11] =  0.000000000000000006811200363169728	;
	[12] = -0.0000000000000000000298834135069877	;
	[13] =  0.00000000000000000000005206467777443879	;
	MaxVel = 131.982147	;
	MaxAng =  89.703169402899221	;
};
SAE416Dat[4][360000][300] = {
	MinVel = -30.080072000000001	;
	MinAng =  24.111280371753843	;
	[0] = 43.646362511409023	;
	[1] =  0.6772994255672351	;
	[2] = -0.0049391588051598337	;
	[3] = -0.00011935405604758488	;
	[4] =  0.0000086091856743454141	;
	[5] =  0.000000022160737377580773	;
	[6] = -0.000000010319804098794369	;
	[7] =  0.00000000015947944997449014	;
	[8] =  0.0000000000034121135361375173	;
	[9] = -0.00000000000014366231273823442	;
	[10] =  0.0000000000000020705236731544509	;
	[11] = -0.000000000000000015407874638742619	;
	[12] =  0.000000000000000000059412890459364283	;
	[13] = -0.000000000000000000000094220809042369421	;
	MaxVel = 126.936729	;
	MaxAng =  84.144386664003832	;
};
SAE416Dat[4][360000][1000] = {
	MinVel = -30.839376000000001	;
	MinAng =  24.781780153267793	;
	[0] = 44.366150939473215	;
	[1] =  0.6750385927847562	;
	[2] = -0.0045884039456137587	;
	[3] = -0.00014878096217435174	;
	[4] =  0.0000084145032595928559	;
	[5] =  0.00000001885544786525919	;
	[6] = -0.0000000089175242969261503	;
	[7] =  0.00000000014761358332342217	;
	[8] =  0.0000000000021251409572996408	;
	[9] = -0.00000000000010130653206660964	;
	[10] =  0.0000000000000014732792406571056	;
	[11] = -0.000000000000000010925404880763512	;
	[12] =  0.000000000000000000041856852036732383	;
	[13] = -0.000000000000000000000065899458718558486	;
	MaxVel = 127.68446400000001	;
	MaxAng =  84.745491906214738	;
};
SAE416Dat[4][360000][2000] = {
	MinVel = -30.030391999999999	;
	MinAng =  27.06312191738337	;
	[0] = 45.519910689077292	;
	[1] =  0.58911084381273848	;
	[2] = -0.0023876738746598306	;
	[3] =  0.00011730449809505775	;
	[4] = -0.0000017559127039152661	;
	[5] = -0.00000025032781255782207	;
	[6] =  0.0000000079221347646576327	;
	[7] =  0.000000000018571014558722658	;
	[8] = -0.0000000000045557973247403732	;
	[9] =  0.000000000000093475076886267657	;
	[10] = -0.00000000000000092982829537120903	;
	[11] =  0.0000000000000000050307493963376183	;
	[12] = -0.000000000000000000013986063564051515	;
	[13] =  0.000000000000000000000015231481062646109	;
	MaxVel = 125.90849300000001	;
	MaxAng =  84.637961604810698	;
};
SAE416Dat[4][360000][3000] = {
	MinVel = -30.010691000000001	;
	MinAng =  29.396647306130617	;
	[0] = 46.392274834930589	;
	[1] =  0.6005814222243322	;
	[2] = -0.00036561021672414443	;
	[3] = -0.000079769014943534516	;
	[4] = -0.0000020588985287102842	;
	[5] =  0.00000011350940057238321	;
	[6] = -0.0000000012261600026581336	;
	[7] = -0.000000000051708702625123248	;
	[8] =  0.0000000000026407244659618327	;
	[9] = -0.000000000000057558974150785428	;
	[10] =  0.00000000000000071068720328711656	;
	[11] = -0.0000000000000000050914758573936826	;
	[12] =  0.000000000000000000019708257551797473	;
	[13] = -0.000000000000000000000031886105504469353	;
	MaxVel = 127.024086	;
	MaxAng =  86.802746193963685	;
};
SAE416Dat[4][360000][4000] = {
	MinVel = -30.902301999999999	;
	MinAng =  30.511286733948776	;
	[0] = 47.495868458972467	;
	[1] =  0.6071628676035612	;
	[2] = -0.0013817928933440998	;
	[3] = -0.0002419024987208372	;
	[4] =  0.0000053467370055573717	;
	[5] =  0.00000022847901131423208	;
	[6] = -0.000000012437020162575018	;
	[7] =  0.00000000011010774992169603	;
	[8] =  0.0000000000052532105430991439	;
	[9] = -0.00000000000017537220737777347	;
	[10] =  0.0000000000000024385245827091101	;
	[11] = -0.000000000000000018205828072032338	;
	[12] =  0.000000000000000000071511317803580927	;
	[13] = -0.00000000000000000000011633635097204861	;
	MaxVel = 127.99580400000001	;
	MaxAng =  88.095697742246557	;
};
SAE416Dat[4][360000][5000] = {
	MinVel = -31.037319	;
	MinAng =  31.138506997527752	;
	[0] = 48.621909101832131	;
	[1] =  0.55008544491000799	;
	[2] = -0.0029038601450033612	;
	[3] =  0.00001580290399123439	;
	[4] =  0.0000042986356572283024	;
	[5] = -0.00000017972105781008748	;
	[6] = -0.0000000022246824847576502	;
	[7] =  0.00000000018577517949267368	;
	[8] = -0.0000000000018015903823342656	;
	[9] = -0.000000000000041367615143919542	;
	[10] =  0.0000000000000011441469357710413	;
	[11] = -0.000000000000000011264817055649371	;
	[12] =  0.00000000000000000005208656354510068	;
	[13] = -0.000000000000000000000094676329327926886	;
	MaxVel = 127.02113300000001	;
	MaxAng =  87.069877771078609	;
};
SAE416Dat[4][360000][6000] = {
	MinVel = -30.019521999999998	;
	MinAng =  33.949142349442923	;
	[0] = 49.550414716470613	;
	[1] =  0.58743495382973643	;
	[2] = -0.0034018609101947178	;
	[3] = -0.00024993870941957983	;
	[4] =  0.0000088348340744998056	;
	[5] =  0.00000019531301744322074	;
	[6] = -0.000000014189952859501796	;
	[7] =  0.00000000014117918500856557	;
	[8] =  0.0000000000055908235571825731	;
	[9] = -0.00000000000019041750705751517	;
	[10] =  0.0000000000000026304495557703535	;
	[11] = -0.000000000000000019469384565536994	;
	[12] =  0.000000000000000000075952493258003368	;
	[13] = -0.00000000000000000000012305475425515634	;
	MaxVel = 127.963036	;
	MaxAng =  88.436182354402263	;
};
function SAE416Ang(Vel, Vl2, Vl3, Vl4, Vl5, Vl6, Vl7, Vl8, Vl9, V10, V11, V12, V13, Bld, Alt, Pwr)
		local Ang;

		if ( Vel > SAE416Dat[Bld][Pwr][Alt].MaxVel ) then
			Ang = SAE416Dat[Bld][Pwr][Alt].MaxAng ;
		elseif ( Vel < SAE416Dat[Bld][Pwr][Alt].MinVel ) then
			Ang = SAE416Dat[Bld][Pwr][Alt].MinAng ;
		else
			Ang
			 = SAE416Dat[Bld][Pwr][Alt][13] * V13
			 + SAE416Dat[Bld][Pwr][Alt][12] * V12
			 + SAE416Dat[Bld][Pwr][Alt][11] * V11
			 + SAE416Dat[Bld][Pwr][Alt][10] * V10
			 + SAE416Dat[Bld][Pwr][Alt][9] * Vl9
			 + SAE416Dat[Bld][Pwr][Alt][8] * Vl8
			 + SAE416Dat[Bld][Pwr][Alt][7] * Vl7
			 + SAE416Dat[Bld][Pwr][Alt][6] * Vl6
			 + SAE416Dat[Bld][Pwr][Alt][5] * Vl5
			 + SAE416Dat[Bld][Pwr][Alt][4] * Vl4
			 + SAE416Dat[Bld][Pwr][Alt][3] * Vl3
			 + SAE416Dat[Bld][Pwr][Alt][2] * Vl2
			 + SAE416Dat[Bld][Pwr][Alt][1] * Vel
			 + SAE416Dat[Bld][Pwr][Alt][0] ;
		end

		return Ang;
end
function SAE416(Vel, Alt, Pwr, AngVel, Bld)
	if (Pwr == 0) then
		if (Vel < 0) then
			return 45;
		else
			local Ang = math.deg(math.atan2(Vel, AngVel * 0.6));
			if (Vel < 1) then
				Ang = Ang * Vel +(1 -Vel) *45;
			end
			return Ang;
		end
	end
	local Vl2 = Vel * Vel;
	local Vl3 = Vl2 * Vel;
	local Vl4 = Vl3 * Vel;
	local Vl5 = Vl4 * Vel;
	local Vl6 = Vl5 * Vel;
	local Vl7 = Vl6 * Vel;
	local Vl8 = Vl7 * Vel;
	local Vl9 = Vl8 * Vel;
	local V10 = Vl9 * Vel;
	local V11 = V10 * Vel;
	local V12 = V11 * Vel;
	local V13 = V12 * Vel;
	local Bld = Bld;
	if (Bld <= 2) then
		Bld = 2;
	elseif (Bld >= 4) then
		Bld = 4;
	else
		Bld = math.floor(Bld + 0.5);
	end
	local Ang;
	local LowPwr;
	local HigPwr;
	local PwrBal;
	if (Pwr < SAE416DatPwr[ 1 ]) then
		LowPwr = SAE416DatPwr[ 1 ];
		HigPwr = SAE416DatPwr[ 1 ];
		PwrBal = 0;
	else
		local SAE416DatPwrLen = table.getn(SAE416DatPwr);
		for i = 2, SAE416DatPwrLen do
			if (Pwr <= SAE416DatPwr[ i ]) then
				LowPwr = SAE416DatPwr[ i - 1 ];
				HigPwr = SAE416DatPwr[ i ];

				break;
			end
		end

		if (LowPwr == nil) then
			LowPwr = SAE416DatPwr[ SAE416DatPwrLen ];
			HigPwr = SAE416DatPwr[ SAE416DatPwrLen ];
			PwrBal = 1;
		else
			PwrBal = (Pwr - LowPwr) / (HigPwr - LowPwr);
		end
	end
	if (Alt < -0.45) then

		local AngLowPwr = SAE416Ang(Vel, Vl2, Vl3, Vl4, Vl5, Vl6, Vl7, Vl8, Vl9, V10, V11, V12, V13, Bld, 0, LowPwr);
		local AngHigPwr = SAE416Ang(Vel, Vl2, Vl3, Vl4, Vl5, Vl6, Vl7, Vl8, Vl9, V10, V11, V12, V13, Bld, 0, HigPwr);

		Ang = (1 - PwrBal) * AngLowPwr + PwrBal * AngHigPwr;

	elseif (Alt <= SAE416DatAlt[ 1 ]) then

		local AngLowPwr = SAE416Ang(Vel, Vl2, Vl3, Vl4, Vl5, Vl6, Vl7, Vl8, Vl9, V10, V11, V12, V13, Bld, SAE416DatAlt[ 1 ], LowPwr);
		local AngHigPwr = SAE416Ang(Vel, Vl2, Vl3, Vl4, Vl5, Vl6, Vl7, Vl8, Vl9, V10, V11, V12, V13, Bld, SAE416DatAlt[ 1 ], HigPwr);

		Ang = (1 - PwrBal) * AngLowPwr + PwrBal * AngHigPwr;

	else
		local HigAlt;
		local LowAlt;
		local SAE416DatAltLen = table.getn(SAE416DatAlt);
		for i = 2, SAE416DatAltLen do
			if (Alt <= SAE416DatAlt[ i ]) then
				LowAlt = SAE416DatAlt[ i - 1 ];
				HigAlt = SAE416DatAlt[ i ];

				break;
			end
		end

		if (LowAlt == nil) then
			LowAlt = SAE416DatAlt[ SAE416DatAltLen ];
			HigAlt = SAE416DatAlt[ SAE416DatAltLen ];
			AltBal = 1;
		else
			AltBal = (Alt - LowAlt) / (HigAlt - LowAlt);
		end

		local AngLowAltLowPwr = SAE416Ang(Vel, Vl2, Vl3, Vl4, Vl5, Vl6, Vl7, Vl8, Vl9, V10, V11, V12, V13, Bld, LowAlt, LowPwr);
		local AngLowAltHigPwr = SAE416Ang(Vel, Vl2, Vl3, Vl4, Vl5, Vl6, Vl7, Vl8, Vl9, V10, V11, V12, V13, Bld, LowAlt, HigPwr);

		local AngLowAlt = (1 - PwrBal) * AngLowAltLowPwr + PwrBal * AngLowAltHigPwr;

		local AngHigAltLowPwr = SAE416Ang(Vel, Vl2, Vl3, Vl4, Vl5, Vl6, Vl7, Vl8, Vl9, V10, V11, V12, V13, Bld, HigAlt, LowPwr);
		local AngHigAltHigPwr = SAE416Ang(Vel, Vl2, Vl3, Vl4, Vl5, Vl6, Vl7, Vl8, Vl9, V10, V11, V12, V13, Bld, HigAlt, HigPwr);

		local AngHigAlt = (1 - PwrBal) * AngHigAltLowPwr + PwrBal * AngHigAltHigPwr;

		Ang = (1 - AltBal) * AngLowAlt + AltBal * AngHigAlt;
	end
	return Ang;
end

LimitAmmo = 0;           --自機の持つ残り弾薬ポイント。残弾表示やフラグに使ってください。
LimitAmmoMax = 0;
isJetPlaneLimitAmmo = false;--ジェット機ならtrueに汁
isBomberLimitAmmo = true;--爆撃機ならtrueに汁
isLimitAmmoInitialized = false;--内部的な初期化フラグ。いじったらだめーよｗ
Cost100k = 12;           --100k(Option=100000)以上のARMの弾薬コスト
Cost50k = 2;             --50k以上100k未満の弾薬コスト
ListChipType = {};       --ARMのチップ番号を格納
ArmCostList = {}; --発見されたArmのコストを順に収納
function LimitAmmoRegulation()
	--初期設定
	if not isLimitAmmoInitialized then
		--重量に応じて弾薬ポイントを決定
		if isJetPlaneLimitAmmo then
			LimitAmmo = 1200;
		elseif isBomberLimitAmmo then
			LimitAmmo = 600;
		elseif _WEIGHT() <= 2200 then
			LimitAmmo = 500;
		else
			LimitAmmo = (_WEIGHT()-1300)/100*20+350;
		end
		LimitAmmoMax= LimitAmmo;
		local chipNum = _CHIPS() - 1;
		for i = 1, chipNum do
			--ARMチェック
			if _TYPE(i) == 10 then
				--50kの場合、100kの場合でそれぞれ弾薬コストを格納
				if _OPTION(i) == 50000 then
					table.insert(ListChipType, i);
					table.insert(ArmCostList, Cost50k);
				elseif _OPTION(i) >= 100000 then
					table.insert(ListChipType, i);
					table.insert(ArmCostList, Cost100k);
				end
			end 
		end
		isLimitAmmoInitialized = true;
	elseif _TICKS() > 150 then
		--発射カウント
		local n = table.getn(ListChipType);
		for i = 1, n do
			--発射判定
			if _E(ListChipType[i]) == 0 and _TOP(ListChipType[i]) == 0 then
				LimitAmmo = LimitAmmo - ArmCostList[i];  --弾薬ポイントから弾薬コストを減算
			end
		end
		local h = _H(0);
		local speed = _VZ(0);
		if (0 < h and h < 2) and math.abs(speed) < 1.5 then
			if isJetPlaneLimitAmmo then
				LimitAmmo = LimitAmmo + 1;
			else
				LimitAmmo = LimitAmmo + 0.5;
			end
			if LimitAmmo > LimitAmmoMax then LimitAmmo = LimitAmmoMax; end
		end
	end
end
}
